{
  "#!": {
    "prefix": "#!",
    "body": "#!/usr/bin/env python\n# encoding: utf-8\n$0",
    "description": "Shebang header for python scripts"
  },
  "ifmain": {
    "prefix": "ifmain",
    "body": "if __name__ == '__main__':\n\t${1:main()}$0",
    "description": "ifmain"
  },
  "class": {
    "prefix": "class",
    "body": "class ${1:MyClass}(${2:object}):\n\t`!p snip.rv = tripple_quotes(snip)`${3:Docstring for $1 }`!p snip.rv = tripple_quotes(snip)`\n\n\tdef __init__(self$4):\n\t\t`!p snip.rv = tripple_quotes(snip)`${5:@todo: to be defined1}`!p\nsnip.rv = \"\"\nsnip >> 2\n\nargs = get_args(t[4])\n\nwrite_docstring_args(args, snip)\nif args:\n    snip.rv += '\\n' + snip.mkline('', indent='')\n    snip += '{0}'.format(tripple_quotes(snip))\n\nwrite_init_body(args, t[2], snip)\n`\n\t\t$0",
    "description": "class with docstrings"
  },
  "slotclass": {
    "prefix": "slotclass",
    "body": "class ${1:MyClass}(${2:object}):\n\t`!p snip.rv = tripple_quotes(snip)`${3:Docstring for $1 }`!p snip.rv = tripple_quotes(snip)`\n`!p\nsnip >> 1\nargs = get_args(t[4])\nwrite_slots_args(args, snip)\n`\n\n\tdef __init__(self$4):\n\t\t`!p snip.rv = tripple_quotes(snip)`${5:@todo: to be defined}`!p\nsnip.rv = \"\"\nsnip >> 2\n\nargs = get_args(t[4])\n\nwrite_docstring_args(args, snip)\nif args:\n    snip.rv += '\\n' + snip.mkline('', indent='')\n    snip += tripple_quotes(snip)\n\nwrite_init_body(args, t[2], snip)\n`\n\t\t$0",
    "description": "class with slots and docstrings"
  },
  "contain": {
    "prefix": "contain",
    "body": "def __len__(self):\n\t${1:pass}\n\ndef __getitem__(self, key):\n\t${2:pass}\n\ndef __setitem__(self, key, value):\n\t${3:pass}\n\ndef __delitem__(self, key):\n\t${4:pass}\n\ndef __iter__(self):\n\t${5:pass}\n\ndef __reversed__(self):\n\t${6:pass}\n\ndef __contains__(self, item):\n\t${7:pass}",
    "description": "methods for emulating a container type"
  },
  "context": {
    "prefix": "context",
    "body": "def __enter__(self):\n\t${1:pass}\n\ndef __exit__(self, exc_type, exc_value, traceback):\n\t${2:pass}",
    "description": "context manager methods"
  },
  "attr": {
    "prefix": "attr",
    "body": "def __getattr__(self, name):\n\t${1:pass}\n\ndef __setattr__(self, name, value):\n\t${2:pass}\n\ndef __delattr__(self, name):\n\t${3:pass}",
    "description": "methods for customizing attribute access"
  },
  "desc": {
    "prefix": "desc",
    "body": "def __get__(self, instance, owner):\n\t${1:pass}\n\ndef __set__(self, instance, value):\n\t${2:pass}\n\ndef __delete__(self, instance):\n\t${3:pass}",
    "description": "methods implementing descriptors"
  },
  "cmp": {
    "prefix": "cmp",
    "body": "def __eq__(self, other):\n\t${1:pass}\n\ndef __ne__(self, other):\n\t${2:pass}\n\ndef __lt__(self, other):\n\t${3:pass}\n\ndef __le__(self, other):\n\t${4:pass}\n\ndef __gt__(self, other):\n\t${5:pass}\n\ndef __ge__(self, other):\n\t${6:pass}\n\ndef __cmp__(self, other):\n\t${7:pass}",
    "description": "methods implementing rich comparison"
  },
  "repr": {
    "prefix": "repr",
    "body": "def __repr__(self):\n\t${1:pass}\n\ndef __str__(self):\n\t${2:pass}\n\ndef __unicode__(self):\n\t${3:pass}",
    "description": "methods implementing string representation"
  },
  "numeric": {
    "prefix": "numeric",
    "body": "def __add__(self, other):\n\t${1:pass}\n\ndef __sub__(self, other):\n\t${2:pass}\n\ndef __mul__(self, other):\n\t${3:pass}\n\ndef __div__(self, other):\n\t${4:pass}\n\ndef __truediv__(self, other):\n\t${5:pass}\n\ndef __floordiv__(self, other):\n\t${6:pass}\n\n\ndef __mod__(self, other):\n\t${7:pass}\n\ndef __divmod__(self, other):\n\t${8:pass}\n\ndef __pow__(self, other):\n\t${9:pass}\n\n\ndef __lshift__(self, other):\n\t${10:pass}\n\ndef __rshift__(self, other):\n\t${11:pass}\n\ndef __and__(self, other):\n\t${12:pass}\n\ndef __xor__(self, other):\n\t${13:pass}\n\ndef __or__(self, other):\n\t${14:pass}\n\n\ndef __neg__(self):\n\t${15:pass}\n\ndef __pos__(self):\n\t${16:pass}\n\ndef __abs__(self):\n\t${17:pass}\n\ndef __invert__(self):\n\t${18:pass}\n\n\ndef __complex__(self):\n\t${19:pass}\n\ndef __int__(self):\n\t${20:pass}\n\ndef __long__(self):\n\t${21:pass}\n\ndef __float__(self):\n\t${22:pass}\n\n\ndef __oct__(self):\n\t${22:pass}\n\ndef __hex__(self):\n\t${23:pass}\n\n\ndef __index__(self):\n\t${24:pass}\n\ndef __coerce__(self, other):\n\t${25:pass}",
    "description": "methods for emulating a numeric type"
  },
  "def": {
    "prefix": "def",
    "body": "def ${1:function}(`!p\nif snip.indent:\n   snip.rv = 'self' + (\", \" if len(t[2]) else \"\")`${2:arg1}):\n\t`!p snip.rv = tripple_quotes(snip)`${4:@todo: Docstring for $1}`!p\nsnip.rv = \"\"\nsnip >> 1\n\nargs = get_args(t[2])\nif args:\n   write_docstring_args(args, snip)\n\nstyle = get_style(snip)\nsnip += format_return(style)\nsnip.rv += '\\n' + snip.mkline('', indent='')\nsnip += tripple_quotes(snip) `\n\t${0:pass}",
    "description": "function with docstrings"
  },
  "/(^|(?<=\\W))\\./": {
    "prefix": "/(^|(?<=\\W))\\./",
    "body": "self.",
    "description": "self."
  },
  "from": {
    "prefix": "from",
    "body": "from ${1:module} import ${2:Stuff}",
    "description": "from module import name"
  },
  "roprop": {
    "prefix": "roprop",
    "body": "@property\ndef ${1:property}(self):\n\t${2:return self._$1}$0",
    "description": "Read Only Property"
  },
  "rwprop": {
    "prefix": "rwprop",
    "body": "def ${1:property}():\n\t${2/.+/(?0:`!p snip.rv = tripple_quotes(snip)`)/}${2:The RW property $1}`!p if t[2]:\n   snip.rv += '\"\"\"'\n   snip >> 1\n   snip += \"\"\nelse:\n   snip.rv = \"\"`def fget(self):\n\t\treturn self._$1$0\n\tdef fset(self, value):\n\t\tself._$1 = value\n\treturn locals()\n$1 = property(**$1())",
    "description": "Read write property"
  },
  "if": {
    "prefix": "if",
    "body": "if ${1:condition}:\n   ${2:pass}",
    "description": "If"
  },
  "ife": {
    "prefix": "ife",
    "body": "if ${1:condition}:\n   ${2:pass}\nelse:\n   ${3:pass}",
    "description": "If / Else"
  },
  "ifee": {
    "prefix": "ifee",
    "body": "if ${1:condition}:\n   ${2:pass}\nelif ${3:condition}:\n   ${4:pass}\nelse:\n   ${5:pass}",
    "description": "If / Elif / Else"
  },
  "try": {
    "prefix": "try",
    "body": "try:\n\t${1:pass}\nexcept${2: ${3:Exception}, ${4:e}}:\n\t${5:raise}\nelse:\n\t${6:pass}\nfinally:\n\t${7:pass}",
    "description": "Try / Except / Else / Finally"
  },
  "pdb": {
    "prefix": "pdb",
    "body": "import pdb; pdb.set_trace()",
    "description": "Set PDB breakpoint"
  },
  "ipdb": {
    "prefix": "ipdb",
    "body": "import ipdb; ipdb.set_trace()",
    "description": "Set IPDB breakpoint"
  },
  "ae": {
    "prefix": "ae",
    "body": "self.assertEqual(${1:first},${2:second})",
    "description": "Assert equal"
  },
  "at": {
    "prefix": "at",
    "body": "self.assertTrue(${0:exp})",
    "description": "Assert True"
  },
  "af": {
    "prefix": "af",
    "body": "self.assertFalse(${1:expression})",
    "description": "Assert False"
  },
  "aae": {
    "prefix": "aae",
    "body": "self.assertAlmostEqual(${1:first},${2:second})",
    "description": "Assert almost equal"
  },
  "ar": {
    "prefix": "ar",
    "body": "self.assertRaises(${1:exception}, ${2:func}${3/.+/, /}${3:arguments})",
    "description": "Assert raises"
  },
  "testcase": {
    "prefix": "testcase",
    "body": "class Test${1:Class}(${2:unittest.TestCase}):\n\t`!p snip.rv = tripple_quotes(snip)`${3:Test case docstring}`!p snip.rv = tripple_quotes(snip)`\n\n\tdef setUp(self):\n\t\t${4:pass}\n\n\tdef tearDown(self):\n\t\t${5:pass}\n\n\tdef test_${6:name}(self):\n\t\t${7:pass}",
    "description": "pyunit testcase"
  }
}